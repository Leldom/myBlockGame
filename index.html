<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="MyBlocks">
    
    <title>My Block Game</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --grid-bg: #16213e;
            --cell-empty: #0f3460;
            --cell-filled: #e94560;
            --gap: 4px;
        }

        body {
            background-color: var(--bg-color);
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* Wichtig: Kein Scrollen */
            touch-action: none; /* Wichtig für Drag & Drop */
        }

        #score-board {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 20px;
        }

        /* Das 8x8 Gitter */
        #game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: var(--gap);
            background-color: var(--grid-bg);
            padding: var(--gap);
            border-radius: 8px;
            width: 90vw; /* Responsive */
            height: 90vw;
            max-width: 400px;
            max-height: 400px;
        }

        .cell {
            background-color: var(--cell-empty);
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .cell.filled {
            background-color: var(--cell-filled);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
        }

        /* Bereich für die neuen Steine */
        #spawn-area {
            margin-top: 40px;
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 400px;
            height: 100px;
        }

        .shape-container {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Der eigentliche Stein (CSS Grid für die Form) */
        .shape {
            display: grid;
            gap: 2px;
            pointer-events: auto; /* Muss greifbar sein */
        }
        
        .shape-block {
            width: 20px;
            height: 20px;
            background-color: var(--cell-filled);
            border-radius: 2px;
        }

        /* Klasse während des Draggings */
        .dragging {
            position: fixed;
            z-index: 1000;
            pointer-events: none; /* Damit wir das Element DAHINTER erkennen */
            opacity: 0.9;
            transform: scale(1.2) translate(-50%, -150%); /* Versatz, damit Finger nicht im Weg ist */
        }
    </style>
</head>
<body>

    <div id="score-board">0</div>
    <div id="game-board"></div>
    <div id="spawn-area"></div>

    <script>
        const BOARD_SIZE = 8;
        const boardEl = document.getElementById('game-board');
        const spawnEl = document.getElementById('spawn-area');
        const scoreEl = document.getElementById('score-board');
        
        let grid = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
        let score = 0;

        // 1. Initialisierung des Boards
        function initBoard() {
            boardEl.innerHTML = '';
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    let cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    boardEl.appendChild(cell);
                }
            }
        }

        // 2. Formen-Definitionen (Als 2D Matrizen: 1 = Block, 0 = Leer)
        const SHAPES = [
            [[1]], // 1x1
            [[1,1,1]], // Linie 3
            [[1,1,1,1]], // Linie 4
            [[1,1,1,1,1]], // Linie 5
            [[1,1],[1,0]], // 2x2 Ecke
            [[1,1],[1,1]], // 2x2 Würfel
            [[1,0],[1,0],[1,1]], // L-Form
            [[1,1,1],[0,1,0]] // T-Form
        ];

        function createShapeElement(matrix) {
            const shapeDiv = document.createElement('div');
            shapeDiv.classList.add('shape');
            shapeDiv.style.gridTemplateColumns = `repeat(${matrix[0].length}, 20px)`;
            
            // Matrix rendern
            matrix.forEach((row, rIndex) => {
                row.forEach((val, cIndex) => {
                    const block = document.createElement('div');
                    if (val === 1) block.classList.add('shape-block');
                    shapeDiv.appendChild(block);
                });
            });

            shapeDiv.dataset.matrix = JSON.stringify(matrix);
            return shapeDiv;
        }

        function spawnShapes() {
            spawnEl.innerHTML = '';
            // 3 neue Formen generieren
            for(let i=0; i<3; i++) {
                const container = document.createElement('div');
                container.classList.add('shape-container');
                const randomShape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                const shapeEl = createShapeElement(randomShape);
                
                addDragLogic(shapeEl);
                container.appendChild(shapeEl);
                spawnEl.appendChild(container);
            }
        }

        // 3. Drag & Drop Logik
        function addDragLogic(el) {
            let startX, startY;
            
            const touchStart = (e) => {
                e.preventDefault(); // Verhindert Scrollen
                const touch = e.touches[0];
                
                // Klonen für das Dragging
                const clone = el.cloneNode(true);
                clone.classList.add('dragging');
                clone.style.width = el.offsetWidth + 'px'; // Größe fixieren
                document.body.appendChild(clone);
                
                const moveAt = (pageX, pageY) => {
                    clone.style.left = pageX + 'px';
                    clone.style.top = pageY + 'px';
                };
                
                moveAt(touch.pageX, touch.pageY);
                el.style.opacity = '0'; // Original unsichtbar machen

                const touchMove = (e) => {
                    const t = e.touches[0];
                    moveAt(t.pageX, t.pageY);
                };

                const touchEnd = (e) => {
                    document.removeEventListener('touchmove', touchMove);
                    document.removeEventListener('touchend', touchEnd);
                    
                    // Wo haben wir losgelassen? (Nutze changedTouches)
                    const t = e.changedTouches[0];
                    checkDrop(clone, el, t.clientX, t.clientY);
                };

                document.addEventListener('touchmove', touchMove, {passive: false});
                document.addEventListener('touchend', touchEnd);
            };

            el.addEventListener('touchstart', touchStart, {passive: false});
        }

        function checkDrop(draggedEl, originalEl, x, y) {
            // Umrechnung Bildschirm -> Grid
            // Wir prüfen, welches Element UNTER dem Finger ist (mit einem Offset, da der User den Stein oft etwas höher sieht)
            // Hinweis: Im echten Spiel müsstest du den Offset des Fingers zum Stein genau berechnen.
            // Hier ein einfacher Ansatz: Wir nehmen den Punkt unter dem Finger - 50px (wegen Offset)
            
            const boardRect = boardEl.getBoundingClientRect();
            // Offset korrigieren (siehe CSS translate -150%)
            const fingerY_Correction = y - (draggedEl.offsetHeight * 1.5); 
            
            // Einfache Kollisionserkennung: Ist der Finger (korrigiert) über dem Board?
            if (x > boardRect.left && x < boardRect.right && 
                fingerY_Correction > boardRect.top && fingerY_Correction < boardRect.bottom) {
                
                // Berechne relative Position im Grid (0-7)
                // Dies ist vereinfacht und nimmt die linke obere Ecke des Steins
                const cellSize = boardRect.width / BOARD_SIZE;
                const col = Math.floor((x - boardRect.left - (draggedEl.offsetWidth/2)) / cellSize); 
                const row = Math.floor((fingerY_Correction - boardRect.top) / cellSize);

                const matrix = JSON.parse(originalEl.dataset.matrix);

                if (canPlace(matrix, row, col)) {
                    placeShape(matrix, row, col);
                    draggedEl.remove();
                    originalEl.parentNode.innerHTML = ''; // Entferne aus Spawn-Area
                    updateBoard();
                    checkLines();
                    
                    // Neue Steine wenn leer
                    if(spawnEl.children.length === 0 || 
                       Array.from(spawnEl.children).every(c => c.innerHTML === '')) {
                        spawnShapes();
                    }
                    return;
                }
            }

            // Wenn ungültig: Zurücksetzen
            draggedEl.remove();
            originalEl.style.opacity = '1';
        }

        // 4. Spiellogik
        function canPlace(matrix, r, c) {
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++) {
                    if (matrix[i][j] === 1) {
                        let targetR = r + i;
                        let targetC = c + j;
                        // Außerhalb des Grids?
                        if (targetR < 0 || targetR >= BOARD_SIZE || targetC < 0 || targetC >= BOARD_SIZE) return false;
                        // Schon belegt?
                        if (grid[targetR][targetC] === 1) return false;
                    }
                }
            }
            return true;
        }

        function placeShape(matrix, r, c) {
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++) {
                    if (matrix[i][j] === 1) {
                        grid[r + i][c + j] = 1;
                    }
                }
            }
        }

        function updateBoard() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);
                if (grid[r][c] === 1) cell.classList.add('filled');
                else cell.classList.remove('filled');
            });
            scoreEl.innerText = score;
        }

        function checkLines() {
            let rowsClears = [];
            let colsClears = [];

            // Zeilen prüfen
            for(let r=0; r<BOARD_SIZE; r++) {
                if(grid[r].every(val => val === 1)) {
                    grid[r].fill(0);
                    score += 10;
                }
            }
            // Spalten prüfen (etwas komplexer zu lesen)
            for(let c=0; c<BOARD_SIZE; c++) {
                let full = true;
                for(let r=0; r<BOARD_SIZE; r++) {
                    if(grid[r][c] === 0) full = false;
                }
                if(full) {
                    for(let r=0; r<BOARD_SIZE; r++) grid[r][c] = 0;
                    score += 10;
                }
            }
            updateBoard();
        }

        // Start
        initBoard();
        spawnShapes();

    </script>
</body>
</html>