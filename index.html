<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>MyBlockGame - Color Edition</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --grid-bg: #16213e;
            --cell-empty: #0f3460;
            --text-color: #fff;
            --gap: 4px;
        }

        /* --- FARBPALETTE (Tetris Style) --- */
        .c-1 { background-color: #00f0f0; box-shadow: inset 0 0 4px rgba(0,0,0,0.25); } /* Cyan */
        .c-2 { background-color: #0000f0; box-shadow: inset 0 0 4px rgba(0,0,0,0.25); } /* Blau */
        .c-3 { background-color: #f0a000; box-shadow: inset 0 0 4px rgba(0,0,0,0.25); } /* Orange */
        .c-4 { background-color: #f0f000; box-shadow: inset 0 0 4px rgba(0,0,0,0.25); } /* Gelb */
        .c-5 { background-color: #00f000; box-shadow: inset 0 0 4px rgba(0,0,0,0.25); } /* Grün */
        .c-6 { background-color: #a000f0; box-shadow: inset 0 0 4px rgba(0,0,0,0.25); } /* Lila */
        .c-7 { background-color: #f00000; box-shadow: inset 0 0 4px rgba(0,0,0,0.25); } /* Rot */

        /* Geister-Steine (Vorschau) - Halbtransparent */
        .preview.c-1 { background-color: rgba(0, 240, 240, 0.4); box-shadow: 0 0 5px #00f0f0; }
        .preview.c-2 { background-color: rgba(0, 0, 240, 0.4); box-shadow: 0 0 5px #0000f0; }
        .preview.c-3 { background-color: rgba(240, 160, 0, 0.4); box-shadow: 0 0 5px #f0a000; }
        .preview.c-4 { background-color: rgba(240, 240, 0, 0.4); box-shadow: 0 0 5px #f0f000; }
        .preview.c-5 { background-color: rgba(0, 240, 0, 0.4); box-shadow: 0 0 5px #00f000; }
        .preview.c-6 { background-color: rgba(160, 0, 240, 0.4); box-shadow: 0 0 5px #a000f0; }
        .preview.c-7 { background-color: rgba(240, 0, 0, 0.4); box-shadow: 0 0 5px #f00000; }

        body.combo-mode {
            /* Hintergrund wird rötlicher bei Combo */
            background-color: #2e1a1a;
            transition: background-color 0.5s;
        }

       body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            transition: background-color 0.5s ease;
        }

        #ui-top {
            display: flex;
            justify-content: space-between;
            width: 90vw;
            max-width: 400px;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: bold;
        }

        #combo-display {
            opacity: 0;
            color: #ffcc00;
            transition: opacity 0.3s, transform 0.2s;
            text-shadow: 0 0 10px red;
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: var(--gap);
            background-color: var(--grid-bg);
            padding: var(--gap);
            border-radius: 12px;
            width: 90vw;
            height: 90vw;
            max-width: 400px;
            max-height: 400px;
            transition: background-color 0.5s ease;
        }

        .cell {
            background-color: var(--cell-empty);
            border-radius: 4px;
            transition: transform 0.2s;
        }

        .cell.clearing {
            animation: flashAndShrink 0.5s forwards;
        }

        @keyframes flashAndShrink {
            0% { filter: brightness(2); transform: scale(1); }
            50% { filter: brightness(2); transform: scale(1.1); }
            100% { background-color: var(--cell-empty); transform: scale(0); opacity: 0;}
        }

        #spawn-area {
            margin-top: 40px;
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 400px;
            height: 100px;
        }

        .shape-container {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .shape {
            display: grid;
            gap: 2px;
        }
        
        .shape-block {
            width: 20px;
            height: 20px;
            border-radius: 2px;
            /* Farbe wird per Klasse gesetzt */
        }

        .dragging {
            position: fixed;
            z-index: 1000;
            pointer-events: none;
            opacity: 0.9;
            transform-origin: center center; 
        }
        .hidden { display: none !important; }

        #game-over-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
        }

        .game-over-box {
            background: var(--bg-color);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid #fff;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
        }

        .game-over-box h2 {
            font-size: 2.5rem;
            margin: 0 0 10px 0;
            color: #e94560;
        }

        .game-over-box button {
            background: #e94560;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="ui-top">
        <div id="score-board">Score: 0</div>
        <div id="combo-display"></div>
    </div>
    
    <div id="game-board"></div>
    <div id="spawn-area"></div>
    
    <div id="game-over-overlay" class="hidden">
        <div class="game-over-box">
            <h2>Game Over!</h2>
            <p id="final-score">Score: 0</p>
            <button onclick="resetGame()">Neustart</button>
        </div>
    </div>

    <script>
        const BOARD_SIZE = 8;
        const boardEl = document.getElementById('game-board');
        const spawnEl = document.getElementById('spawn-area');
        const scoreEl = document.getElementById('score-board');
        const comboEl = document.getElementById('combo-display');
        
        // Grid speichert jetzt IDs: 0 = leer, 1-7 = Farbe
        let grid = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
        let score = 0;

        function initBoard() {
            boardEl.innerHTML = '';
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    let cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.id = `cell-${r}-${c}`;
                    boardEl.appendChild(cell);
                }
            }
        }

        const SHAPES = [
            [[1]], 
            [[1,1]], [[1],[1]], 
            [[1,1,1]], [[1],[1],[1]], 
            [[1,1,1,1]], [[1],[1],[1],[1]], 
            [[1,1,1,1,1]], [[1],[1],[1],[1],[1]], 
            [[1,1],[1,1]], 
            [[1,1,1],[1,1,1],[1,1,1]], 
            [[1,0],[1,0],[1,1]], [[0,1],[0,1],[1,1]], 
            [[1,1],[1,0],[1,0]], [[1,1],[0,1],[0,1]], 
            [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]], 
            [[1,1,1],[0,1,0]], [[0,1,0],[1,1,1]], 
            [[0,1],[1,1],[0,1]], [[1,0],[1,1],[1,0]], 
            [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]], 
            [[0,1],[1,1],[1,0]], [[1,0],[1,1],[0,1]], 
        ];

        function createShapeElement(matrix, colorId) {
            const shapeDiv = document.createElement('div');
            shapeDiv.classList.add('shape');
            shapeDiv.style.gridTemplateColumns = `repeat(${matrix[0].length}, 20px)`;
            
            // Speichere die Farb-ID im Dataset für später
            shapeDiv.dataset.colorId = colorId;
            shapeDiv.dataset.matrix = JSON.stringify(matrix);

            matrix.forEach((row) => {
                row.forEach((val) => {
                    const block = document.createElement('div');
                    if (val === 1) {
                        block.classList.add('shape-block');
                        block.classList.add(`c-${colorId}`); // Farbe zuweisen
                    }
                    shapeDiv.appendChild(block);
                });
            });
            return shapeDiv;
        }

        function spawnShapes() {
            spawnEl.innerHTML = '';
            for(let i=0; i<3; i++) {
                const container = document.createElement('div');
                container.classList.add('shape-container');
                
                const randomShape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                // Zufällige Farbe 1 bis 7
                const randomColor = Math.floor(Math.random() * 7) + 1;
                
                const shapeEl = createShapeElement(randomShape, randomColor);
                addDragLogic(shapeEl);
                container.appendChild(shapeEl);
                spawnEl.appendChild(container);
            }
        }

        function clearPreview() {
            // Entfernt alle Preview-Klassen (auch die Farbspezifischen)
            document.querySelectorAll('.cell.preview').forEach(el => {
                el.className = 'cell'; // Reset auf Basis-Klasse
                // Falls die Zelle eigentlich gefüllt ist, müssen wir das visualisieren
                // Das macht updateBoardVisuals normalerweise, aber hier reicht simpler Reset,
                // da wir beim Draggen dauernd updaten.
                // Besser:
                const [_, r, c] = el.id.split('-');
                const val = grid[r][c];
                if(val > 0) el.classList.add(`c-${val}`);
            });
        }

        function showPreview(matrix, r, c, colorId) {
            clearPreview();
            if (!canPlace(matrix, r, c)) return;

            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++) {
                    if (matrix[i][j] === 1) {
                        const cell = document.getElementById(`cell-${r+i}-${c+j}`);
                        if (cell) {
                            cell.classList.add('preview');
                            cell.classList.add(`c-${colorId}`);
                        }
                    }
                }
            }
        }

        const DRAG_OFFSET_Y = 100; 

        function getGridCoords(x, y, shapeEl) {
            const boardRect = boardEl.getBoundingClientRect();
            const targetX = x;
            const targetY = y - DRAG_OFFSET_Y;

            if (targetX > boardRect.left && targetX < boardRect.right && 
                targetY > boardRect.top && targetY < boardRect.bottom) {
                
                const cellSize = boardRect.width / BOARD_SIZE;
                const cols = parseInt(shapeEl.dataset.cols || 1);
                const rows = parseInt(shapeEl.dataset.rows || 1);

                const col = Math.floor((targetX - boardRect.left) / cellSize - (cols - 1) / 2); 
                const row = Math.floor((targetY - boardRect.top) / cellSize - (rows - 1) / 2);
                
                return { r: row, c: col, valid: true };
            }
            return { r: 0, c: 0, valid: false };
        }

        function addDragLogic(el) {
            let clone;
            const matrix = JSON.parse(el.dataset.matrix);
            const colorId = el.dataset.colorId;
            
            el.dataset.rows = matrix.length;
            el.dataset.cols = matrix[0].length;

            const touchStart = (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const boardRect = boardEl.getBoundingClientRect();
                const gridCellSize = boardRect.width / BOARD_SIZE;
                const scaleFactor = gridCellSize / 20;

                clone = el.cloneNode(true);
                clone.classList.add('dragging');
                clone.style.width = el.offsetWidth + 'px'; 
                document.body.appendChild(clone);
                
                const moveAt = (pageX, pageY) => {
                    clone.style.left = (pageX - el.offsetWidth / 2) + 'px';
                    clone.style.top = (pageY - el.offsetHeight / 2 - DRAG_OFFSET_Y) + 'px';
                    clone.style.transform = `scale(${scaleFactor})`;
                };
                
                moveAt(touch.pageX, touch.pageY);
                el.style.opacity = '0';

                const touchMove = (e) => {
                    const t = e.touches[0];
                    moveAt(t.pageX, t.pageY);
                    const coords = getGridCoords(t.clientX, t.clientY, clone);
                    if (coords.valid) {
                        showPreview(matrix, coords.r, coords.c, colorId);
                    } else {
                        clearPreview();
                    }
                };

                const touchEnd = (e) => {
                    document.removeEventListener('touchmove', touchMove);
                    document.removeEventListener('touchend', touchEnd);
                    clearPreview();
                    
                    const t = e.changedTouches[0];
                    const coords = getGridCoords(t.clientX, t.clientY, clone);

                    if (coords.valid && canPlace(matrix, coords.r, coords.c)) {
                        placeShape(matrix, coords.r, coords.c, colorId);
                        clone.remove();
                        el.parentNode.innerHTML = ''; 
                        updateBoardVisuals(); 
                        setTimeout(() => checkLinesAndSpawn(), 50);
                    } else {
                        clone.remove();
                        el.style.opacity = '1';
                    }
                };
                document.addEventListener('touchmove', touchMove, {passive: false});
                document.addEventListener('touchend', touchEnd);
            };
            el.addEventListener('touchstart', touchStart, {passive: false});
        }

        function canPlace(matrix, r, c) {
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++) {
                    if (matrix[i][j] === 1) {
                        let targetR = r + i;
                        let targetC = c + j;
                        // Out of bounds oder Feld nicht 0 (belegt)
                        if (targetR < 0 || targetR >= BOARD_SIZE || targetC < 0 || targetC >= BOARD_SIZE) return false;
                        if (grid[targetR][targetC] !== 0) return false;
                    }
                }
            }
            return true;
        }

        function placeShape(matrix, r, c, colorId) {
            // +10 Punkte für das bloße Platzieren
            score += 10;
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++) {
                    if (matrix[i][j] === 1) {
                        // Speichere die Farb-ID im Grid (String zu Int konvertieren zur Sicherheit)
                        grid[r + i][c + j] = parseInt(colorId);
                    }
                }
            }
        }

        function updateBoardVisuals() {
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.getElementById(`cell-${r}-${c}`);
                    const val = grid[r][c];
                    
                    // Zuerst alle Farbklassen entfernen
                    cell.className = 'cell'; 
                    if(cell.classList.contains('clearing')) cell.classList.add('clearing'); // Animation erhalten

                    if (val > 0) {
                        cell.classList.add(`c-${val}`);
                    }
                }
            }
            scoreEl.innerText = `Score: ${score}`;
        }

        function checkLinesAndSpawn() {
            let cellsToClear = []; 
            let linesCleared = 0;

            // Zeilen prüfen (alle != 0)
            for(let r=0; r<BOARD_SIZE; r++) {
                if(grid[r].every(val => val !== 0)) {
                    linesCleared++;
                    for(let c=0; c<BOARD_SIZE; c++) cellsToClear.push({r, c});
                }
            }
            // Spalten prüfen
            for(let c=0; c<BOARD_SIZE; c++) {
                let full = true;
                for(let r=0; r<BOARD_SIZE; r++) if(grid[r][c] === 0) full = false;
                if(full) {
                    linesCleared++;
                    for(let r=0; r<BOARD_SIZE; r++) cellsToClear.push({r, c});
                }
            }

            if (cellsToClear.length > 0) {
                // Duplikate entfernen (Kreuzungspunkte)
                const uniqueCells = [];
                const map = new Map();
                for (const item of cellsToClear) {
                    const key = `${item.r}-${item.c}`;
                    if(!map.has(key)){
                        map.set(key, true);
                        uniqueCells.push(item);
                    }
                }

                // --- SCORING & COMBO LOGIK ---
                // Nur bei 3 oder mehr Linien gleichzeitig gibt es den "COMBO" Status
                let points = 0;
                let isCombo = false;

                if (linesCleared === 1) points = 100;
                else if (linesCleared === 2) points = 300;
                else if (linesCleared === 3) { points = 600; isCombo = true; } // Combo Start
                else if (linesCleared === 4) { points = 1000; isCombo = true; }
                else if (linesCleared >= 5)  { points = 2000; isCombo = true; }

                if (isCombo) {
                    // Multiplikator logik: Je mehr Linien, desto heftiger
                    const multiplier = linesCleared; 
                    points = points * multiplier;
                    
                    document.body.classList.add('combo-mode');
                    comboEl.innerText = `${linesCleared}x COMBO!`;
                    comboEl.style.opacity = '1';
                    comboEl.style.transform = 'scale(1.5)';
                } else {
                    document.body.classList.remove('combo-mode');
                    comboEl.style.opacity = '0';
                    comboEl.style.transform = 'scale(1)';
                }

                score += points;

                // Animation starten
                uniqueCells.forEach(obj => {
                    const cell = document.getElementById(`cell-${obj.r}-${obj.c}`);
                    cell.classList.add('clearing');
                });

                setTimeout(() => {
                    uniqueCells.forEach(obj => {
                        grid[obj.r][obj.c] = 0;
                        const cell = document.getElementById(`cell-${obj.r}-${obj.c}`);
                        cell.className = 'cell'; // Reset komplett
                    });
                    
                    // Combo Text ausblenden nach kurzer Zeit
                    if(isCombo) {
                        setTimeout(() => {
                            comboEl.style.opacity = '0';
                            comboEl.style.transform = 'scale(1)';
                            document.body.classList.remove('combo-mode');
                        }, 1500);
                    }

                    updateBoardVisuals();
                    checkSpawnRefill();
                }, 500); 

            } else {
                checkSpawnRefill();
            }
        }

        function checkSpawnRefill() {
            const shapes = Array.from(spawnEl.querySelectorAll('.shape'));
            if(shapes.length === 0) {
                spawnShapes();
            }
            setTimeout(() => {
                checkGameOver();
            }, 250);
        }

        function checkGameOver() {
            const shapes = Array.from(spawnEl.querySelectorAll('.shape'));
            if (shapes.length === 0) return;

            let movePossible = false;
            for (let s = 0; s < shapes.length; s++) {
                const shapeEl = shapes[s];
                const matrix = JSON.parse(shapeEl.dataset.matrix);
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (canPlace(matrix, r, c)) {
                            movePossible = true;
                            break; 
                        }
                    }
                    if (movePossible) break;
                }
                if (movePossible) break;
            }

            if (!movePossible) {
                showGameOver();
            }
        }
        
        function showGameOver() {
            document.getElementById('final-score').innerText = 'Score: ' + score;
            document.getElementById('game-over-overlay').classList.remove('hidden');
        }

        function resetGame() {
            score = 0;
            grid = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            updateBoardVisuals();
            document.getElementById('game-over-overlay').classList.add('hidden');
            spawnShapes();
        }

        initBoard();
        spawnShapes();

    </script>
</body>
</html>