<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="BlockBlast">
    
    <title>Block Blast Clone</title>
    <style>
        :root {
            /* Standard Theme (Deep Blue) */
            --bg-color: #1a1a2e;
            --grid-bg: #16213e;
            --cell-empty: #0f3460;
            --cell-filled: #e94560;
            --cell-preview: rgba(233, 69, 96, 0.4);
            --text-color: #fff;
            --gap: 4px;
        }

        /* Combo Theme (Fire / Gold) - Wird per JS aktiviert */
        body.combo-mode {
            --bg-color: #2e1a1a;
            --grid-bg: #3e1616;
            --cell-empty: #600f0f;
            --cell-filled: #ffcc00; /* Gold */
            --cell-preview: rgba(255, 204, 0, 0.4);
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            touch-action: none;
            transition: background-color 0.5s ease;
        }

        #ui-top {
            display: flex;
            justify-content: space-between;
            width: 90vw;
            max-width: 400px;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: bold;
        }

        #combo-display {
            opacity: 0;
            color: #ffcc00;
            transition: opacity 0.3s;
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: var(--gap);
            background-color: var(--grid-bg);
            padding: var(--gap);
            border-radius: 12px;
            width: 90vw;
            height: 90vw;
            max-width: 400px;
            max-height: 400px;
            transition: background-color 0.5s ease;
            position: relative; /* Für Effekte */
        }

        .cell {
            background-color: var(--cell-empty);
            border-radius: 4px;
            transition: background-color 0.2s, transform 0.2s;
        }
        
        .cell.filled {
            background-color: var(--cell-filled);
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
        }

        /* Vorschau (Ghost) */
        .cell.preview {
            background-color: var(--cell-preview);
            box-shadow: 0 0 5px var(--cell-filled);
        }

        /* Animation beim Löschen */
        .cell.clearing {
            animation: flashAndShrink 0.4s forwards;
        }

        @keyframes flashAndShrink {
            0% { background-color: #fff; transform: scale(1); }
            50% { background-color: #fff; transform: scale(1.1); }
            100% { background-color: var(--cell-empty); transform: scale(0); }
        }

        #spawn-area {
            margin-top: 40px;
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 400px;
            height: 100px;
        }

        .shape-container {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .shape {
            display: grid;
            gap: 2px;
        }
        
        .shape-block {
            width: 20px;
            height: 20px;
            background-color: var(--cell-filled);
            border-radius: 2px;
        }

        /* Update im Style-Bereich */
        .dragging {
            position: fixed;
            z-index: 1000;
            pointer-events: none;
            opacity: 0.9;
            /* Wir steuern Transform jetzt per JS für die perfekte Größe */
            transform-origin: center center; 
        }
        .hidden {
            display: none !important;
        }

        #game-over-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
        }

        .game-over-box {
            background: var(--bg-color);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid var(--cell-filled);
            box-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
        }

        .game-over-box h2 {
            font-size: 2.5rem;
            margin: 0 0 10px 0;
            color: var(--cell-filled);
        }

        .game-over-box button {
            background: var(--cell-filled);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="ui-top">
        <div id="score-board">Score: 0</div>
        <div id="combo-display">COMBO!</div>
    </div>
    
    <div id="game-board"></div>
    <div id="spawn-area"></div>
    <div id="game-over-overlay" class="hidden">
    <div class="game-over-box">
        <h2>Game Over!</h2>
        <p id="final-score">Score: 0</p>
        <button onclick="resetGame()">Neustart</button>
    </div>
</div>

    <script>
        const BOARD_SIZE = 8;
        const boardEl = document.getElementById('game-board');
        const spawnEl = document.getElementById('spawn-area');
        const scoreEl = document.getElementById('score-board');
        const comboEl = document.getElementById('combo-display');
        
        let grid = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
        let score = 0;
        let comboMultiplier = 0;
        let movesWithoutClear = 0;

        // --- 1. SETUP ---

        function initBoard() {
            boardEl.innerHTML = '';
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    let cell = document.createElement('div');
                    cell.classList.add('cell');
                    // IDs für schnelleren Zugriff
                    cell.id = `cell-${r}-${c}`;
                    boardEl.appendChild(cell);
                }
            }
        }

        // Formen
        const SHAPES = [
            [[1]], //1 Block
            [[1,1]], // 2 Line
            [[1],[1]], // 2 Stack
            [[1,1,1]], // 3 Line
            [[1],[1],[1]], // 3 Stack
            [[1,1,1,1]], // 4 Line
            [[1],[1],[1],[1]], // 4 Stack
            [[1,1,1,1,1]], // 5 Line
            [[1],[1],[1],[1],[1]], // 5 Stack
            [[1,1],[1,1]], // 2x2 Cube
            [[1,1,1],[1,1,1],[1,1,1]], // 3x3
            [[1,0],[1,0],[1,1]], // L
            [[0,1],[0,1],[1,1]], // Reverse L
            [[1,1],[1,0],[1,0]], // L 180
            [[1,1],[0,1],[0,1]], // Reverse L 180
            [[1,0,0],[1,1,1]], // Long L
            [[0,0,1],[1,1,1]], // Reverse Long L
            [[1,1,1],[0,1,0]], // T
            [[0,1,0],[1,1,1]], // Reverse T
            [[0,0,1],[1,1,1],[0,0,1]], // Long T
            [[1,0,0],[1,1,1],[1,0,0]], // Reverse Long T
            [[1,1,0],[0,1,1]],  // Z
            [[0,1,1],[1,1,0]], // Reverse Z
            [[0,1],[1,1],[1,0]], // Z vertical
            [[1,0],[1,1],[0,1]], // Reverse Z vertical
        ];

        function createShapeElement(matrix) {
            const shapeDiv = document.createElement('div');
            shapeDiv.classList.add('shape');
            shapeDiv.style.gridTemplateColumns = `repeat(${matrix[0].length}, 20px)`;
            
            matrix.forEach((row) => {
                row.forEach((val) => {
                    const block = document.createElement('div');
                    if (val === 1) block.classList.add('shape-block');
                    shapeDiv.appendChild(block);
                });
            });
            shapeDiv.dataset.matrix = JSON.stringify(matrix);
            return shapeDiv;
        }

        function spawnShapes() {
            spawnEl.innerHTML = '';
            for(let i=0; i<3; i++) {
                const container = document.createElement('div');
                container.classList.add('shape-container');
                const randomShape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                const shapeEl = createShapeElement(randomShape);
                addDragLogic(shapeEl);
                container.appendChild(shapeEl);
                spawnEl.appendChild(container);
            }
        }

        // --- 2. LOGIK & GHOST EFFEKT ---

       

        function clearPreview() {
            document.querySelectorAll('.cell.preview').forEach(el => el.classList.remove('preview'));
        }

        function showPreview(matrix, r, c) {
            clearPreview();
            if (!canPlace(matrix, r, c)) return;

            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++) {
                    if (matrix[i][j] === 1) {
                        const cell = document.getElementById(`cell-${r+i}-${c+j}`);
                        if (cell) cell.classList.add('preview');
                    }
                }
            }
        }

        // Konstante für den Abstand über dem Finger (in Pixeln)
        const DRAG_OFFSET_Y = 100; 

        function getGridCoords(x, y, shapeEl) {
            const boardRect = boardEl.getBoundingClientRect();
            
            // Wir nehmen exakt den Punkt über dem Finger (minus Offset)
            const targetX = x;
            const targetY = y - DRAG_OFFSET_Y;

            // Ist dieser Punkt innerhalb des Boards?
            if (targetX > boardRect.left && targetX < boardRect.right && 
                targetY > boardRect.top && targetY < boardRect.bottom) {
                
                const cellSize = boardRect.width / BOARD_SIZE;
                
                // Umrechnung in Spalte/Zeile
                // Wir zentrieren den Block logisch auf dem Finger
                // shapeEl.dataset.cols speichert, wie breit der Block in Zellen ist
                const cols = parseInt(shapeEl.dataset.cols || 1);
                const rows = parseInt(shapeEl.dataset.rows || 1);

                // Wir berechnen die linke obere Ecke des Blocks basierend auf der Mitte
                const col = Math.floor((targetX - boardRect.left) / cellSize - (cols - 1) / 2); 
                const row = Math.floor((targetY - boardRect.top) / cellSize - (rows - 1) / 2);
                
                return { r: row, c: col, valid: true };
            }
            return { r: 0, c: 0, valid: false };
        }

        function addDragLogic(el) {
            let clone;
            const matrix = JSON.parse(el.dataset.matrix);
            
            // Speichere Dimensionen für Zentrierung
            el.dataset.rows = matrix.length;
            el.dataset.cols = matrix[0].length;

            const touchStart = (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                
                // 1. Gitter-Größe berechnen
                const boardRect = boardEl.getBoundingClientRect();
                const gridCellSize = boardRect.width / BOARD_SIZE;
                const currentBlockSize = 20; // Unsere CSS Größe der kleinen Blöcke (20px)
                
                // Skalierungsfaktor berechnen (Damit der Block exakt ins Gitter passt)
                const scaleFactor = gridCellSize / currentBlockSize;

                clone = el.cloneNode(true);
                clone.classList.add('dragging');
                // Breite fixieren, damit Layout beim Draggen nicht bricht
                clone.style.width = el.offsetWidth + 'px'; 
                
                document.body.appendChild(clone);
                
                // Positionierung & Skalierung
                const moveAt = (pageX, pageY) => {
                    clone.style.left = (pageX - el.offsetWidth / 2) + 'px';
                    clone.style.top = (pageY - el.offsetHeight / 2 - DRAG_OFFSET_Y) + 'px';
                    clone.style.transform = `scale(${scaleFactor})`;
                };
                
                moveAt(touch.pageX, touch.pageY);
                el.style.opacity = '0';

                const touchMove = (e) => {
                    const t = e.touches[0];
                    moveAt(t.pageX, t.pageY);
                    
                    const coords = getGridCoords(t.clientX, t.clientY, clone);
                    if (coords.valid) {
                        showPreview(matrix, coords.r, coords.c);
                    } else {
                        clearPreview();
                    }
                };

                const touchEnd = (e) => {
                    document.removeEventListener('touchmove', touchMove);
                    document.removeEventListener('touchend', touchEnd);
                    clearPreview();
                    
                    const t = e.changedTouches[0];
                    const coords = getGridCoords(t.clientX, t.clientY, clone);

                    if (coords.valid && canPlace(matrix, coords.r, coords.c)) {
                        placeShape(matrix, coords.r, coords.c);
                        clone.remove();
                        el.parentNode.innerHTML = ''; 
                        updateBoardVisuals(); 
                        setTimeout(() => checkLinesAndSpawn(), 50);
                    } else {
                        // Zurück fliegen lassen (optional, hier einfach entfernen)
                        clone.remove();
                        el.style.opacity = '1';
                    }
                };

                document.addEventListener('touchmove', touchMove, {passive: false});
                document.addEventListener('touchend', touchEnd);
            };

            el.addEventListener('touchstart', touchStart, {passive: false});
        }

        function canPlace(matrix, r, c) {
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++) {
                    if (matrix[i][j] === 1) {
                        let targetR = r + i;
                        let targetC = c + j;
                        if (targetR < 0 || targetR >= BOARD_SIZE || targetC < 0 || targetC >= BOARD_SIZE) return false;
                        if (grid[targetR][targetC] === 1) return false;
                    }
                }
            }
            return true;
        }

        function placeShape(matrix, r, c) {
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++) {
                    if (matrix[i][j] === 1) {
                        grid[r + i][c + j] = 1;
                    }
                }
            }
        }

        function updateBoardVisuals() {
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.getElementById(`cell-${r}-${c}`);
                    // Reset classes carefully (don't remove animation classes yet)
                    if (grid[r][c] === 1) cell.classList.add('filled');
                    else if (!cell.classList.contains('clearing')) { 
                        cell.classList.remove('filled');
                    }
                }
            }
            scoreEl.innerText = `Score: ${score}`;
        }

        // --- 3. CLEAR LOGIK & ANIMATIONEN ---

        function checkLinesAndSpawn() {
            let cellsToClear = []; // Speichert {r, c} Objekte
            let linesCleared = 0;

            // Zeilen prüfen
            for(let r=0; r<BOARD_SIZE; r++) {
                if(grid[r].every(val => val === 1)) {
                    linesCleared++;
                    for(let c=0; c<BOARD_SIZE; c++) cellsToClear.push({r, c});
                }
            }
            // Spalten prüfen
            for(let c=0; c<BOARD_SIZE; c++) {
                let full = true;
                for(let r=0; r<BOARD_SIZE; r++) if(grid[r][c] === 0) full = false;
                if(full) {
                    linesCleared++;
                    for(let r=0; r<BOARD_SIZE; r++) cellsToClear.push({r, c});
                }
            }

            if (cellsToClear.length > 0) {
                // COMBO LOGIK
                comboMultiplier++;
                movesWithoutClear = 0;
                updateComboVisuals(linesCleared);

                // 1. Animation starten
                cellsToClear.forEach(obj => {
                    const cell = document.getElementById(`cell-${obj.r}-${obj.c}`);
                    cell.classList.add('clearing');
                });

                // 2. Warten, dann logisch löschen
                setTimeout(() => {
                    cellsToClear.forEach(obj => {
                        grid[obj.r][obj.c] = 0;
                        const cell = document.getElementById(`cell-${obj.r}-${obj.c}`);
                        cell.classList.remove('filled', 'clearing');
                    });
                    
                    score += (linesCleared * 10) * comboMultiplier;
                    updateBoardVisuals();
                    checkSpawnRefill();
                }, 400); // Entspricht der CSS Animation Time

            } else {
                // Kein Clear
                movesWithoutClear++;
                if(movesWithoutClear > 2) {
                    comboMultiplier = 0;
                    document.body.classList.remove('combo-mode');
                    comboEl.style.opacity = '0';
                }
                checkSpawnRefill();
            }
        }

        function updateComboVisuals(linesCleared) {
            // Wenn Combo oder Multiline Clear -> Aktiviere Theme
            if (comboMultiplier > 1 || linesCleared > 1) {
                document.body.classList.add('combo-mode');
                comboEl.innerText = `COMBO x${comboMultiplier}!`;
                comboEl.style.opacity = '1';
            }
        }

 function checkSpawnRefill() {
            // 1. Sind alle Steine weg?
            const shapes = Array.from(spawnEl.querySelectorAll('.shape'));
            
            // Wichtig: Wir prüfen, ob die Container leer sind ODER ob gar keine Shapes mehr da sind
            // (Manchmal bleibt ein leerer Container stehen)
            if(shapes.length === 0) {
                spawnShapes();
            }
            
            // 2. Game Over prüfen - mit etwas mehr Verzögerung für Sicherheit
            setTimeout(() => {
                checkGameOver();
            }, 250); // Erhöht auf 250ms, damit der Browser Zeit zum Rendern hat
        }

        function checkGameOver() {
            // Hol alle Steine, die JETZT gerade verfügbar sind
            const shapes = Array.from(spawnEl.querySelectorAll('.shape'));
            
            if (shapes.length === 0) return; // Keine Steine da? Dann kein Game Over möglich.

            let movePossible = false;

            // Prüfe jeden verfügbaren Stein
            for (let s = 0; s < shapes.length; s++) {
                const shapeEl = shapes[s];
                const matrix = JSON.parse(shapeEl.dataset.matrix);

                // Prüfe für diesen Stein JEDE mögliche Position auf dem Brett
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (canPlace(matrix, r, c)) {
                            movePossible = true;
                            break; // Dieser Stein passt irgendwo! Spiel geht weiter.
                        }
                    }
                    if (movePossible) break;
                }
                if (movePossible) break;
            }

            // Wenn nach Prüfung ALLER Steine kein Move möglich war -> Game Over
            if (!movePossible) {
                showGameOver();
            }
        }
        function showGameOver() {
            document.getElementById('final-score').innerText = 'Score: ' + score;
            document.getElementById('game-over-overlay').classList.remove('hidden');
        }

        function resetGame() {
            score = 0;
            comboMultiplier = 0;
            movesWithoutClear = 0;
            grid = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            
            // UI Reset
            updateBoardVisuals();
            document.getElementById('game-over-overlay').classList.add('hidden');
            document.body.classList.remove('combo-mode');
            comboEl.style.opacity = '0';
            
            // Neue Steine
            spawnShapes();
        }

        // Start
        initBoard();
        spawnShapes();

    </script>
</body>
</html>